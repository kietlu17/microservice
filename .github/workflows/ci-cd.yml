name: CI - tests (docker compose)

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    name: Build services and run tests
    runs-on: ubuntu-latest
    env:
      DOCKERHUB_USER: ${{ secrets.DOCKERHUB_USERNAME }}
      DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create .env files for services
        run: |
          set -e
          mkdir -p api-gateway auth order product

          # api-gateway
          printf "AUTH_SERVICE='http://auth_service:3000'\n" > api-gateway/.env
          printf "ORDER_SERVICE='http://order_service:3002'\n" >> api-gateway/.env
          printf "PRODUCT_SERVICE='http://product_service:3001'\n" >> api-gateway/.env
          printf "PORT_API=3003\n" >> api-gateway/.env

          # auth
          printf "MONGODB_AUTH_URI=\"mongodb://mongodb/auth\"\n" > auth/.env
          printf "JWT_SECRET=\"secret\"\n" >> auth/.env

          # order
          printf "MONGODB_ORDER_URI='mongodb://mongodb/orders'\n" > order/.env
          printf "RABBITMQ_URI='amqp://rabbitmq?frameMax=0x2000'\n" >> order/.env
          printf "RABBITMQ_QUEUE_ORDERS='orders'\n" >> order/.env
          printf "RABBITMQ_QUEUE_PRODUCTS='products'\n" >> order/.env
          printf "PORT_ORDER=3002\n" >> order/.env

          # product (kept your original PORT_PROUDUCT and also add PORT_PRODUCT)
          printf "JWT_SECRET=\"secret\"\n" > product/.env
          printf "MONGODB_PRODUCT_URI=\"mongodb://mongodb/products\"\n" >> product/.env
          printf "MONGODB_ORDER_URI='mongodb://mongodb/orders'\n" >> product/.env
          printf "RABBITMQ_URI='amqp://rabbitmq?frameMax=0x2000'\n" >> product/.env
          printf "RABBITMQ_QUEUE_ORDERS='orders'\n" >> product/.env
          printf "RABBITMQ_QUEUE_PRODUCTS='products'\n" >> product/.env
          printf "PORT_PROUDUCT=3001\n" >> product/.env
          printf "PORT_PRODUCT=3001\n" >> product/.env
          printf "LOGIN_TEST_USER='testuser'\n" >> product/.env
          printf "LOGIN_TEST_PASSWORD='password'\n" >> product/.env

      - name: Build images
        run: |
          docker compose build --parallel

      - name: Run all service
        run: |
          docker compose up -d 

      - name: Wait for MongoDB
        run: |
          echo "Waiting for MongoDB on port 27017..."
          for i in $(seq 1 30); do nc -z localhost 27017 && break || sleep 2; done

      - name: Wait for RabbitMQ management
        run: |
          echo "Waiting for RabbitMQ management on port 15672..."
          for i in $(seq 1 30); do nc -z localhost 15672 && break || sleep 2; done

      - name: Run tests inside auth container
        run: |
          set -e
          docker compose exec auth npm test

      - name: Run tests inside product container (one-off)
        run: |
          set -e
          sleep 20
          docker compose exec product npm test

      - name: Tear down compose
        if: always()
        run: |
          docker compose down --volumes --remove-orphans

      - name: Login to Docker Hub
        if: success()
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Push từng image lên Docker Hub
      - name: Push images to Docker Hub
        if: success()
        run: |
          set -e
          docker tag api-gateway_service ${{ secrets.DOCKERHUB_USERNAME }}/api_gateway:latest
          docker tag auth_service${{ secrets.DOCKERHUB_USERNAME }}/auth:latest
          docker tag order_service ${{ secrets.DOCKERHUB_USERNAME }}/order:latest
          docker tag product_service ${{ secrets.DOCKERHUB_USERNAME }}/product:latest

          docker push ${{ secrets.DOCKERHUB_USERNAME }}/api_gateway:latest
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/auth:latest
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/order:latest
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/product:latest

      - name: Dump docker logs on failure
        if: failure()
        run: |
          docker compose ps || true
          docker compose logs --no-color || true